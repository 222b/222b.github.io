---
title: 软件部分
date: 2017-12-06 04:57:19
---

# 软件部分
	
## 开发环境
编程语言：C++
编译环境：codeblocks 13.12.0.0+OpenCV 2.4.4
所加载类库：OpenCV图像处理库，SerialPort串口读写类


## 图像采集

程序开始时通过摄像头捕捉路线图像。摄像头尽量至于高处，将路线板拍全，否则透视变换会使视差增大。要注意光线不能过暗或过亮，便于二值化将路线准确识别出来。一旦拍下路线板照片，摄像头就不再移动。
　

## 透视变换

用鼠标选取路线板的四个角进行透视变换。将路线板周围的干扰滤去，变换到正的坐标系中，并保存变换矩阵，以备在图像实时采集时用。用到OpenCV的库函数cvGetPerspectiveTransform和cvWarpPerspective函数。在后面实时采集小车和路线板图像时，都将先利用这个固定的变换矩阵对图像进行变换，统一坐标系。


## 二值化

调用cvCvtColor()函数将图像从RGB颜色空间转换为HSV颜色空间，调用cvInRangeS()函数将背景置黑、跑道置白；



## 路径细化

将跑道的白色部分宽度细化为一至二个像素，是后续路径点处理更加准确


## 路径规划

 用鼠标顺序点击起点和终点，程序会将离鼠标点击处最近的点分别设为起点和终点；把处于同一带状区域中的点看作一天线段，直线通过；从起点开始，深度优先搜索，得到多条首尾相接的线段。

　


　

小车追踪：包括透视变换、头尾二值化、头尾定位等三个步骤。

透视变换： 同图像处理部分的透视变换；

头尾二值化： 根据头尾“识别区域”的不同颜色分别确定相应的二值化参数，将“识别区域”置白，背景置黑；

头尾定位： 在头和尾的两幅二值化图像上，分别用鼠标按住并拖动，产生一个象征搜索区域的矩形框，将白色区域包括其中，调用cvCamShift()函数可以获得白色区域的外接矩形及其中心坐标，从而分别确定小车头和尾的位置，此后依次迭代使用矩形搜索区域，可实现连续追踪，追踪实时性由搜索频率决定。

　

小车控制

配合硬件部分的间断控制（150ms接受一次信号并且保持状态150ms），系统每150ms扫描一次小车位置，处理后发送给小车。
由小车识别找到小车的车头、车尾的质心后，通过比较小车车身的方向矢量和小车质心到下一个目标点的方向矢量来判别小车该左拐、右拐还是直行；通过比较小车质心到下一个目标点的距离来判断小车该前进还是停止。
当然不可能使小车走的路线和找到的路径完全吻合，需要设定一定的可容许误差，否则小车可能永远也走不到某个点。比如当小车车身的方向与路径的方向角度小于某个角度允许误差时，就可认为是直行。当小车与下一个点的距离小于某个距离允许误差时，就可认为是到达该点并停止。
当小车经过所有找到的路径点后，自动停止，程序退出。
小车控制部分需要通过串口向小车发送字节命令。每次发送一个字节内容，并定义4个字节控制命令：
G：前进
B：后退
L：左转
R：右转